<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory and System Bus - Writing a RISC-V Emulator in Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Writing a RISC-V emulator in Rust to aim to run xv6, a small Unix-like OS.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../theme/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Writing a RISC-V Emulator in Rust</a></li><li class="chapter-item expanded "><a href="../hardware-components/index.html"><strong aria-hidden="true">1.</strong> Hardware Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hardware-components/01-cpu.html"><strong aria-hidden="true">1.1.</strong> CPU with Two Instructions</a></li><li class="chapter-item expanded "><a href="../hardware-components/02-memory.html" class="active"><strong aria-hidden="true">1.2.</strong> Memory and System Bus</a></li><li class="chapter-item expanded "><a href="../hardware-components/03-csrs.html"><strong aria-hidden="true">1.3.</strong> Control and Status Registers</a></li></ol></li><li class="chapter-item expanded "><a href="../instruction-set/index.html"><strong aria-hidden="true">2.</strong> Instruction Set</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../instruction-set/01-rv64i.html"><strong aria-hidden="true">2.1.</strong> RV64I Base Integer Instruction Set</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing a RISC-V Emulator in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#memory-and-system-bus" id="memory-and-system-bus">Memory and System Bus</a></h1>
<p>This is a part of <a href="../"><em>Writing a RISC-V Emulator in Rust</em></a>. Our goal is
running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in
your emulator in the final step.</p>
<p>The source code used in this page is available at
<a href="https://github.com/d0iasm/rvemu-for-book/tree/master/02">d0iasm/rvemu-for-book/02/</a>.</p>
<h2><a class="header" href="#the-goal-of-this-page" id="the-goal-of-this-page">The Goal of This Page</a></h2>
<p>In this page, we will implement a memory (DRAM) and a system bus. The memory is
used to store and load data. The system bus is a pathway to carry data between
the CPU and the memory.</p>
<p>These components enable to execute load and store instructions which are the
part of base integer instruction set. There are 7 load instructions (<code>lb</code>, <code>lh</code>,
<code>lw</code>, <code>ld</code>, <code>lbu</code>, <code>lhu</code>, and <code>lwu</code>) and 4 store instructions (<code>sb</code>, <code>sh</code>, <code>sw</code>,
and <code>sd</code>).</p>
<h2><a class="header" href="#define-modules" id="define-modules">Define Modules</a></h2>
<p>Rust has a powerful module system that can split code into logical units. Each
unit is called a module.</p>
<p>First, we divide <code>main.rs</code> implemented in the previous section. The code of the
CPU is splited to a new file <code>cpu.rs</code>.</p>
<p>To define a CPU module, we need to <code>mod</code> keyword at the beginning of the
<code>main.rs</code> file. The <code>use</code> keyword allows us to use public items defined in the
CPU module.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This declaration will look for a file named `cpu.rs` or `cpu/mod.rs` and
// will insert its contents inside a module named `cpu` under this scope.
mod cpu;

// Use all public structures, methods, and functions defined in the cpu module.
use crate::cpu::*;
<span class="boring">}
</span></code></pre></pre>
<p class="filename">cpu.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `pub` keyword allows other modules use the `Cpu` structure and methods
// relating to it.
pub struct Cpu {
    ...
}

impl Cpu {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#memory-dram" id="memory-dram">Memory (DRAM)</a></h2>
<p>The memory we going to implement is a dynamic random-access memory which is
called DRAM. It is used to store/load data while the program is running.</p>
<p>We represent it as a <code>Dram</code> struct. It contains a vector of bytes as a member.</p>
<p>The vector of bytes in the <code>Dram</code> instance is initialized with the data
containing executable binary when it's created by <code>Dram::new()</code>.</p>
<p class="filename">dram.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const DRAM_SIZE: u64 = 1024 * 1024 * 128; // 128MiB

pub struct Dram {
    pub dram: Vec&lt;u8&gt;,
}

impl Dram {
    pub fn new(code: Vec&lt;u8&gt;) -&gt; Dram {
        let mut dram = vec![0; DRAM_SIZE as usize];
        dram.splice(..code.len(), code.iter().cloned());

        Self { dram }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#load-and-store-methods" id="load-and-store-methods">Load and Store Methods</a></h3>
<p>There are <code>load</code> and <code>store</code> public methods for the <code>Dram</code> struct. Arguments in
each method are an address and the number of bits. The number of bits can be
8, 16, 32, and 64 bits.</p>
<p class="filename">dram.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Dram {
    ...
    pub fn load(&amp;self, addr: u64, size: u64) -&gt; Result&lt;u64, ()&gt; {
        match size {
            8 =&gt; Ok(self.load8(addr)),
            16 =&gt; Ok(self.load16(addr)),
            32 =&gt; Ok(self.load32(addr)),
            64 =&gt; Ok(self.load64(addr)),
            _ =&gt; Err(()),
        }
    }

    pub fn store(&amp;mut self, addr: u64, size: u64, value: u64) -&gt; Result&lt;(), ()&gt; {
        match size {
            8 =&gt; Ok(self.store8(addr, value)),
            16 =&gt; Ok(self.store16(addr, value)),
            32 =&gt; Ok(self.store32(addr, value)),
            64 =&gt; Ok(self.store64(addr, value)),
            _ =&gt; Err(()),
        }
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>load8</code>, <code>load16</code>, <code>load32</code>, and <code>load64</code> (<code>store*</code> as well) are private
methods to help us operate the DRAM with the specific size of bits. The DRAM
is a little-endian system as described in the previous section so we need to be
careful the order of bytes.</p>
<p>The following code is <code>load32</code> and <code>store32</code> methods. The byte of a smallest
memory address (<code>index</code>) is stored at the least signigicant byte at the largest
and the byte of a largest memory address (<code>index + 3</code>) is stored at the most
significant byte of a word.</p>
<p class="filename">dram.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Dram {
    ...

    fn load32(&amp;self, addr: u64) -&gt; u64 {
        let index = (addr - DRAM_BASE) as usize;
        return (self.dram[index] as u64)
            | ((self.dram[index + 1] as u64) &lt;&lt; 8)
            | ((self.dram[index + 2] as u64) &lt;&lt; 16)
            | ((self.dram[index + 3] as u64) &lt;&lt; 24);
    }

    fn store32(&amp;mut self, addr: u64, value: u64) {
        let index = (addr - DRAM_BASE) as usize;
        self.dram[index] = (value &amp; 0xff) as u8;
        self.dram[index + 1] = ((value &gt;&gt; 8) &amp; 0xff) as u8;
        self.dram[index + 2] = ((value &gt;&gt; 16) &amp; 0xff) as u8;
        self.dram[index + 3] = ((value &gt;&gt; 24) &amp; 0xff) as u8;
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#add-dram-to-module" id="add-dram-to-module">Add Dram to Module</a></h3>
<p>Let's add the <code>Dram</code> as a module. Once adding one line at <code>main.rs</code>, <code>dram.rs</code>
can be included to the build target by <code>cargo build</code> and we can use methods
defined at <code>dram.rs</code>.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod dram;
<span class="boring">}
</span></code></pre></pre>
<p>From now on, we will add a new file as a module implicitly when it is added.</p>
<h2><a class="header" href="#system-bus" id="system-bus">System Bus</a></h2>
<p>A system bus is a component to carry data between the CPU and peripheral devices
such as a DRAM. In actual hardware, there are 3 types of a bus. The 3 buses
together are called a system bus.</p>
<ul>
<li>Address bus: carries memory addresses.</li>
<li>Data bus: carries the data.</li>
<li>Control bus: carries control signals.</li>
</ul>
<p>Our implementation doesn't care the differences between them and a system bus
just connects the DRAM (and other peripheral devices) to the CPU and carries
memory addresses and data stored in the memory and between them.</p>
<p>The <code>Bus</code> struct has a <code>dram</code> member and other peripheral devices we will add
later. The <code>Cpu</code> struct now has a <code>bus</code> member in it instead of a <code>dram</code>
member so that the CPU can access the DRAM via a system bus.</p>
<p class="filename">bus.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Bus {
    dram: Dram,
}
<span class="boring">}
</span></code></pre></pre>
<p class="filename">cpu.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cpu {
    pub regs: [u64; 32],
    pub pc: u64,
    pub bus: Bus,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#memory-mapped-io" id="memory-mapped-io">Memory-mapped I/O</a></h3>
<p>Memory-mapped I/O (MMIO) is a method performing input and output between the
CPU and peripheral devices. MMIO uses the same address space as both DRAM and
peripheral devices. It means you can use same <code>load</code> and <code>store</code> instructions
for accessing peripheral devices. When you access at a memory address, it can
connect to either a DRAM or a specific peripheral device via the system bus.</p>
<p>The system bus is responsible for a memory map in our implementation. A memory
map is a structure of data which indicates how memory is laid out for a DRAM
and peripheral devices. This can be different depending on a hardware system.</p>
<p>For example, <a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">virt machine in
QEMU</a> has the
following memory map. In the virt machine, DRAM starts at 0x80000000. We're
going to implement the same memory map as the map of a virt machine although we
only have a part of the peripheral devices the virt machine has.</p>
<pre><code class="language-c">static const struct MemmapEntry {
    hwaddr base;
    hwaddr size;
} virt_memmap[] = {
    [VIRT_DEBUG] =       {        0x0,         0x100 },
    [VIRT_MROM] =        {     0x1000,        0xf000 },
    [VIRT_TEST] =        {   0x100000,        0x1000 },
    [VIRT_RTC] =         {   0x101000,        0x1000 },
    [VIRT_CLINT] =       {  0x2000000,       0x10000 },
    [VIRT_PCIE_PIO] =    {  0x3000000,       0x10000 },
    [VIRT_PLIC] =        {  0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) },
    [VIRT_UART0] =       { 0x10000000,         0x100 },
    [VIRT_VIRTIO] =      { 0x10001000,        0x1000 },
    [VIRT_FLASH] =       { 0x20000000,     0x4000000 },
    [VIRT_PCIE_ECAM] =   { 0x30000000,    0x10000000 },
    [VIRT_PCIE_MMIO] =   { 0x40000000,    0x40000000 },
    [VIRT_DRAM] =        { 0x80000000,           0x0 },
};
</code></pre>
<p>There are <code>load</code> and <code>store</code> public methods for the <code>Bus</code> struct. Arguments in
each method are an address and the number of bits. The number of bits can be
8, 16, 32, and 64.</p>
<p>If the <code>addr</code> is larger than 0x80000000 defined as <code>DRAM_BASE</code>, we can access to the DRAM.</p>
<p class="filename">dram.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The address which dram starts, same as QEMU virt machine.
pub const DRAM_BASE: u64 = 0x8000_0000;

impl Bus {
    ...

    pub fn load(&amp;self, addr: u64, size: u64) -&gt; Result&lt;u64, ()&gt; {
        if DRAM_BASE &lt;= addr {
            return self.dram.load(addr, size);
        }
        Err(())
    }

    pub fn store(&amp;mut self, addr: u64, size: u64, value: u64) -&gt; Result&lt;(), ()&gt; {
        if DRAM_BASE &lt;= addr {
            return self.dram.store(addr, size, value);
        }
        Err(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#update-the-cpu" id="update-the-cpu">Update the CPU</a></h2>
<p>We're going to implement load and store instructions which are the part of base
integer instruction set. There are 7 load instructions, <code>lb</code>, <code>lh</code>, <code>lw</code>,
<code>lbu</code>, and <code>lhu</code> defined at RV32I and <code>lwu</code> and <code>ld</code> defined at RV64I. There
are 4 store instructions, <code>sb</code>, <code>sh</code>, and <code>sw</code> defined at RV32I and <code>sd</code>
defined at RV64I.</p>
<h3><a class="header" href="#fetch-decode-execute-cycle" id="fetch-decode-execute-cycle">Fetch-decode-execute Cycle</a></h3>
<p>We update the fetch-decode-execute cycle introduced in the previous page. The
emulator continues to execute the cycle until <code>fetch</code> or <code>execute</code> methods fail.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    ...
    loop {
        // 1. Fetch.
        let inst = match cpu.fetch() {
            // Break the loop if an error occurs.
            Ok(inst) =&gt; inst,
            Err(_) =&gt; break,
        };

        // 2. Add 4 to the program counter.
        cpu.pc += 4;

        // 3. Decode.
        // 4. Execute.
        match cpu.execute(inst) {
            // Break the loop if an error occurs.
            Ok(_) =&gt; {}
            Err(_) =&gt; break,
        }

        // This is a workaround for avoiding an infinite loop.
        if cpu.pc == 0 {
            break;
        }
    }
    ...
}
</code></pre></pre>
<h3><a class="header" href="#fetch-stage" id="fetch-stage">Fetch Stage</a></h3>
<p>The next executable binary can be fetched from DRAM via the system bus we just
created. The size of bits is 32 since the the length of one instruction in
RISC-V is always 4 bytes. (Note: The length of one instruction can be 2 bytes in
the compressed instruction set.)</p>
<p class="filename">cpu.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...
    pub fn fetch(&amp;mut self) -&gt; Result&lt;u64, ()&gt; {
        match self.bus.load(self.pc, 32) {
            Ok(inst) =&gt; Ok(inst),
            Err(_e) =&gt; Err(()),
        }
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#decode-stage" id="decode-stage">Decode Stage</a></h3>
<p>Load instructions are I-type and store instrucrtions are S-type format as we can
see them in Fig 2.1. and 2.2. The positions for <code>rs1</code>, <code>funct3</code> (the 3 bits
between <code>rs1</code> and <code>rd</code>), and <code>opcode</code> are the same position in the both format.</p>
<p>In RISC-V, there are many common positions in all formats, but decoding an
immediate value is quite different depending on instructions, so we'll decode an
immediate value in each operation.</p>
<p><img src="../img/1-2-1.png" alt="Fig 2.1 Load and store instructions in RV32I." /></p>
<p class="caption">Fig 2.1 Load and store instructions in RV32I.</p>
<p><img src="../img/1-2-2.png" alt="Fig 2.2 Load and store instructions in RV64I." /></p>
<p class="caption">Fig 2.2 Load and store instructions in RV64I.</p>
<p class="filename">cpu.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...
    fn execute(&amp;mut self, inst: u32) {
        ...
        let funct3 = ((inst &gt;&gt; 12) &amp; 0x7);
        ...
        match opcode {
            0x03 =&gt; { // Load instructions.
                // imm[11:0] = inst[31:20]
                let imm = ((inst as i32 as i64) &gt;&gt; 20) as u64;
                let addr = self.regs[rs1].wrapping_add(imm);
                ...
            0x23 =&gt; { // Store instructions.
                // imm[11:5|4:0] = inst[31:25|11:7]
                let imm = (((inst &amp; 0xfe000000) as i32 as i64 &gt;&gt; 20) as u64) | ((inst &gt;&gt; 7) &amp; 0x1f);
                let addr = self.regs[rs1].wrapping_add(imm);
                ...
<span class="boring">}
</span></code></pre></pre>
<p>Decoding is performed by bitwise ANDs and bit shifts. The point to be noted is
that an immediate value should be sign-extended. It means we need to fill in the
upper bits with 1 when the significant bit is 1. In this implementation, filling
in bits with 1 is performed by casting from a signed integer to an unsigned
integer.</p>
<h3><a class="header" href="#execute-stage" id="execute-stage">Execute Stage</a></h3>
<p>Each operation is performed in each <code>match</code> arm. For example, a load
instruction <code>lb</code> is executed when <code>opcode</code> is 0x3 and <code>funct3</code> is 0x0. The
<code>lb</code> instruction loads a byte from a DRAM with the specific <code>addr</code> position.</p>
<p>The suffix in load and store instructions mean the size of bits.</p>
<ul>
<li>b: a byte (8 bits)</li>
<li>h: a half word (16 bits)</li>
<li>w: a word (32 bits)</li>
<li>d: a double word (64 bits)</li>
</ul>
<p>Also, <code>u</code> in load instructions means &quot;unsigned&quot;.</p>
<p class="filename">cpu.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...
    fn execute(&amp;mut self, inst: u32) {
        ...
        match opcode {
            0x03 =&gt; { // Load instructions.
                // imm[11:0] = inst[31:20]
                let imm = ((inst as i32 as i64) &gt;&gt; 20) as u64;
                let addr = self.regs[rs1].wrapping_add(imm);
                match funct3 {
                    0x0 =&gt; {
                        // lb
                        let val = self.load(addr, 8)?;
                        self.regs[rd] = val as i8 as i64 as u64;
                    }
                    0x1 =&gt; {
                        // lh
                        let val = self.load(addr, 16)?;
                        self.regs[rd] = val as i16 as i64 as u64;
                    }
                    0x2 =&gt; {
                        // lw
                        let val = self.load(addr, 32)?;
                        self.regs[rd] = val as i32 as i64 as u64;
                    }
                    0x3 =&gt; {
                        // ld
                        let val = self.load(addr, 64)?;
                        self.regs[rd] = val;
                    }
                    0x4 =&gt; {
                        // lbu
                        let val = self.load(addr, 8)?;
                        self.regs[rd] = val;
                    }
                    0x5 =&gt; {
                        // lhu
                        let val = self.load(addr, 16)?;
                        self.regs[rd] = val;
                    }
                    0x6 =&gt; {
                        // lwu
                        let val = self.load(addr, 32)?;
                        self.regs[rd] = val;
                    }
                    _ =&gt; {}
                }
            }
            0x23 =&gt; { // Store instructions.
                // imm[11:5|4:0] = inst[31:25|11:7]
                let imm = (((inst &amp; 0xfe000000) as i32 as i64 &gt;&gt; 20) as u64) | ((inst &gt;&gt; 7) &amp; 0x1f);
                let addr = self.regs[rs1].wrapping_add(imm);
                match funct3 {
                    0x0 =&gt; self.store(addr, 8, self.regs[rs2])?,  // sb
                    0x1 =&gt; self.store(addr, 16, self.regs[rs2])?, // sh
                    0x2 =&gt; self.store(addr, 32, self.regs[rs2])?, // sw
                    0x3 =&gt; self.store(addr, 64, self.regs[rs2])?, // sd
                    _ =&gt; {}
                }
            }
            ...
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#instruction-set" id="instruction-set">Instruction Set</a></h2>
<p>We implemented <code>add</code> and <code>addi</code> in the previous page and load and store
instructions in this page. These instructions are a part of base integer
instruction set (RV64I). To run xv6 in our emulator, we need to implement all
instructions in RV64I and a part of instructions in RV64A and RV64M.</p>
<p>Here is the page for <a href="../instruction-set/index.html">all instruction set we need to implement for running
xv6</a>:</p>
<ul>
<li><a href="../instruction-set/01-rv64i.html">RV64I Base Integer Instruction Set</a></li>
<li><a href="../instruction-set/02-rv64m.html">&quot;M&quot; Standard Extension for Integer Multiplication and
Division</a></li>
<li><a href="../instruction-set/03-rv64a.html">&quot;A&quot; Standard Extension for
AtomicInstructions</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../hardware-components/01-cpu.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../hardware-components/03-csrs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../hardware-components/01-cpu.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../hardware-components/03-csrs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
