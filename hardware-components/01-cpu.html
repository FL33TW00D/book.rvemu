<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CPU with Two Instructions - Writing a RISC-V Emulator in Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Writing a RISC-V emulator in Rust to aim to run xv6, a small Unix-like OS.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../theme/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Writing a RISC-V Emulator in Rust</a></li><li class="chapter-item expanded "><a href="../hardware-components/index.html"><strong aria-hidden="true">1.</strong> Hardware Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hardware-components/01-cpu.html" class="active"><strong aria-hidden="true">1.1.</strong> CPU with Two Instructions</a></li><li class="chapter-item expanded "><a href="../hardware-components/02-memory.html"><strong aria-hidden="true">1.2.</strong> Memory and System Bus</a></li><li class="chapter-item expanded "><a href="../hardware-components/03-csrs.html"><strong aria-hidden="true">1.3.</strong> Control and Status Registers</a></li></ol></li><li class="chapter-item expanded "><a href="../instruction-set/index.html"><strong aria-hidden="true">2.</strong> Instruction Set</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../instruction-set/01-rv64i.html"><strong aria-hidden="true">2.1.</strong> RV64I Base Integer Instruction Set</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing a RISC-V Emulator in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#cpu-with-two-instructions" id="cpu-with-two-instructions">CPU with Two Instructions</a></h1>
<p>This is a part of <a href="../"><em>Writing a RISC-V Emulator in Rust</em></a>. Our goal is
running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in
your emulator in the final step.</p>
<p>The source code used in this page is available at
<a href="https://github.com/d0iasm/rvemu-for-book/tree/master/01">d0iasm/rvemu-for-book/01/</a>.</p>
<h2><a class="header" href="#the-goal-of-this-page" id="the-goal-of-this-page">The Goal of This Page</a></h2>
<p>In this page, we will implement a simple CPU and we can execute <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/01/add-addi.s">the sample
file</a>
containing <code>add</code> and <code>addi</code> instructions in our emulator. The <code>add</code> instruction
adds 64-bit values in two registers, and the <code>addi</code> instruction adds a 64-bit
value in a register and a 12-bit immediate value.</p>
<p>We successfully see the result of addition in the <code>x31</code> register when we execute
the sample binary file <code>add-addi.bin</code>.</p>
<pre><code class="language-sh">// add-addi.bin contains the following instructions:
// main:
// .  addi x29, x0, 5   // Add 5 and 0, and store the value to x29.
// .  addi x30, x0, 37  // Add 37 and 0, and store the value to x30.
// .  add x31, x30, x29 // x31 should contain 42 (0x2a).

$ cargo run add-addi.bin
...
x28=0x0 x29=0x5 x30=0x25 x31=0x2a
</code></pre>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p><a href="https://riscv.org/">RISC-V</a> is a new instruction-set architecture (ISA) that
was originally designed to support computer architecture research and education
at the University of California, Berkeley, but now it gradually becomes a
standard free and open architecture for industry implementations. RISC-V is also
excellent <strong>for students to learn computer architecture</strong> since it's simple
enough. We can read <a href="https://riscv.org/technical/specifications/">the RISC-V
specifications</a> for free and we'll
implement a part of features in <em>Volume I: Unprivileged ISA</em> and <em>Volume II:
Privileged Architecture</em>. The <em>Unprivileged ISA</em> defines instructions, the
binary that the computer processor (CPU) can understand. Currently, RISC-V
defines 32-bit and 64-bit architecture. The width of registers and the available
memory size is different depending on the architecture. The 128-bit architecture
also exists but it is currently in a draft state.</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is an open-source systems programming
language that focuses on performance and safety. It is popular especially in
systems programming like an operating system. We're going to implement our
emulator in Rust.</p>
<p>An emulator is, in simple words, <strong>an infinite loop to execute a RISC-V binary
one by one</strong> unless something wrong happens or a user stops an emulator
explicitly. In this book, we try to understand the basic RISC-V architecture by
making a RISC-V emulator.</p>
<h2><a class="header" href="#risc-v-isa" id="risc-v-isa">RISC-V ISA</a></h2>
<p>RISC-V ISA consists of modules, a base integer ISA plus optional extensions. The
base integer ISA must be implemented in any platform. There are 2 variants in
the base integer ISA, <strong>RV32I</strong> for a 32-bit architecture and <strong>RV64I</strong> for a
64-bit architecture.</p>
<p>The base integer ISA only contains simple integer arithmetic operations so it's
not enough so that it can't run complex systems such as OSes. RISC-V defines a
combination of a base ISA plus selected extensions as a &quot;general-purpose&quot; ISA,
called <strong>RV32G</strong> or <strong>RV64G</strong>, to allow complex systems to run on RISC-V
hardware.</p>
<p>Here is the list of ISAs that RV64G includes:</p>
<ul>
<li>RV64I: base integer instructions</li>
<li>RV64M: integer multiplication and division instructions</li>
<li>RV64A: atomic instructions</li>
<li>RV64F: single-precision floating-point instructions</li>
<li>RV64D: double-precision floating-point instructions</li>
<li>RVZicsr: control and status register instructions</li>
<li>RVZifencei: instruction-fetch fence instructions</li>
</ul>
<p>We'll only support the instructions that xv6 uses which are RV64I, RVZicsr, a
part of RV64M, and a part of RV64A.</p>
<h2><a class="header" href="#build-risc-v-toolchain" id="build-risc-v-toolchain">Build RISC-V Toolchain</a></h2>
<p>First, we need to build a RISC-V toolchain for RV64G. The default toolchain will
use RV64GC which contains a general-purpose ISA and a compressed ISA. However,
we will not support the compressed ISA in our emulator so we need to tell the
architecture we use to the toolchain.</p>
<p>Download code from the
<a href="https://github.com/riscv/riscv-gnu-toolchain">riscv/riscv-gnu-toolchain</a>
repository and configure it with RV64G architecture. After executing the
following commands, we can use <code>riscv64-unknown-elf-*</code> commands.</p>
<pre><code class="language-sh">$ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
$ cd riscv-gnu-toolchain
$ ./configure --prefix=&lt;path-to-riscv-toolchain&gt; --with-arch=rv64g
$ make &amp;&amp; make linux
// Now we can use riscv64-unknown-elf-* commands!
</code></pre>
<h2><a class="header" href="#create-a-new-project" id="create-a-new-project">Create a New Project</a></h2>
<p>We use Cargo, the Rust package manager. See <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">the installation
page</a> in the
Cargo book to install it. I'll call our project <code>rvemu-for-book</code> because I
originally implemented <a href="https://github.com/d0iasm/rvemu">rvemu</a> and I refactored
<a href="https://github.com/d0iasm/rvemu-for-book">the code for this book</a>.</p>
<p>The command <code>cargo new</code> can make a new project. We can see &quot;Hello, world!&quot; when
we execute an initialized project by <code>cargo run</code>.</p>
<pre><code class="language-bash">$ cargo new rvemu-for-book
$ cd rvemu-for-book
$ cargo run
Hello, world!
</code></pre>
<h2><a class="header" href="#create-a-basic-cpu" id="create-a-basic-cpu">Create a Basic CPU</a></h2>
<p>CPU is the most important part of a computer to execute instructions. It has
<strong>registers</strong>, a small amount of fast storage that a CPU can access. The width
of registers is 64 bits in the 64-bit RISC-V architecture. It also has <strong>a
program counter</strong> to hold the address of the current instruction.</p>
<p>The following struct contains 32 registers, a program counter, and memory.
Actual hardware doesn't have a memory inside a CPU and the memory connects to
the CPU via a system bus. We will make a memory and system bus module on the
next page, and we create a CPU that contains a memory directly for now.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cpu {
    regs: [u64; 32],
    pc: u64,
    code: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#registers" id="registers">Registers</a></h3>
<p>There are 32 general-purpose registers that are each 64 bits wide in RV64I. Each
register has a role defined by <a href="https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#integer-register-convention-">the integer register
convention</a>.
Basically, an emulator doesn't care about the roles of a register except zero
(x0) and sp (x2) registers. The zero register x0 is hardwired with all bits
equal to 0. The sp register x2 is a stack pointer. A stack is a data structure
mainly located at the end of the address space. It is especially used to store
local variables. A stack pointer keeps track of a stack. A value of a stack
pointer is subtracted in <a href="https://en.wikipedia.org/wiki/Function_prologue">a function
prologue</a>, so we need to set it
up with a non-0 value.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set the register x2 with the size of a memory when a CPU is
// instantiated.
regs[2] = MEMORY_SIZE; // 1024 * 1024 * 128 (128MiB).

// Reset the value of register x0 with 0 in each cycle to mimic that
// register x0 is hardwired with all bits equal to 0.
self.regs[0] = 0;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fetch-decode-execute-cycle" id="fetch-decode-execute-cycle">Fetch-decode-execute Cycle</a></h3>
<p>The main job of the CPU is composed of three main stages: fetch stage, decode
stage, and execute stage. The fetch-decode-execute cycle is also known as the
instruction cycle.</p>
<p>A CPU follows the cycle from the computer boots up until it shuts down.  An
emulator is ideally an infinite loop and continues to perform the
fetch-decode-execute cycle infinitely unless something wrong happens or a user
stops an emulator explicitly.  However, we're going to stop an emulator
implicitly when the program counter is 0 or over the length of memory, and an
error happens during the execution.</p>
<ol>
<li>Fetch: Reads the next instruction to be executed from the memory where the
program is stored.</li>
<li>Decode: Splits an instruction sequence into a form that makes sense to the
CPU.</li>
<li>Execute: Performs the action required by the instruction.</li>
</ol>
<p>Also, we need to add 4 bytes, the size of one instruction, to the program
counter in each cycle.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    ...
    while cpu.pc &lt; cpu.dram.len() as u64 {
        // 1. Fetch.
        let inst = cpu.fetch();

        // 2. Add 4 to the program counter.
        cpu.pc = cpu.pc + 4;

        // 3. Decode.
        // 4. Execute.
        cpu.execute(inst);
    }
    ...
</code></pre></pre>
<p>We'll make <code>fetch</code> and <code>execute</code> methods in CPU. The decode stage is performed
in the <code>execute</code> method for the sake of simplicity.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    fn fetch(&amp;self) -&gt; u32 {
        // Read 32-bit instruction from a memory.
    }

    fn execute(&amp;mut self, inst: u32) {
        // Decode an instruction and execute it.
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#set-binary-data-to-the-memory" id="set-binary-data-to-the-memory">Set Binary Data to the Memory</a></h3>
<p>In order to implement the <code>fetch</code> method, we need to read a binary file from a
command line and store the content in the memory. We can get command-line
arguments via the standard <code>env</code> module. Let a file name place at the first
argument.</p>
<p>The binary is set up to the memory when a new CPU instance is created.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() -&gt; io::Result&lt;()&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();

    if args.len() != 2 {
        panic!(&quot;Usage: rvemu-simple &lt;filename&gt;&quot;);
    }
    let mut file = File::open(&amp;args[1])?;
    let mut code = Vec::new();
    file.read_to_end(&amp;mut code)?;

    let cpu = Cpu::new(code);

    ...
}

impl Cpu {
    fn new(code: Vec&lt;u8&gt;) -&gt; Self {
        Self {
            regs: [0; 32],
            pc: 0,
            dram: code,
        }
    }

    fn fetch(&amp;self) -&gt; u32 { ... }
    fn execute(&amp;mut self, inst: u32) { ... }
}
</code></pre></pre>
<h3><a class="header" href="#fetch-stage" id="fetch-stage">Fetch Stage</a></h3>
<p>Now, we are ready to fetch an instruction from the memory.</p>
<p>What we should be careful to fetch an instruction is endianness, which is the
term refers to how binary data is stored. There are 2 types of endianness:
little-endian and big-endian. A little-endian ordering places the least
significant byte (LSB) at the lowest address and the most significant byte
(MSB) places at the highest address in a 32-bit word. While a big-endian
ordering does the opposite.</p>
<p><img src="../img/1-1-1.jpg" alt="Fig 1.1 Little-endian and big-endian 2 instructions." /></p>
<p class="caption">Fig 1.1 Little-endian and big-endian 2 instructions.</p>
<p>RISC-V has either little-endian or big-endian byte order. Our emulator only
supports a little-endian system because RISC-V originally chose little-endian
byte ordering and it's currently dominant commercially like x86 systems.</p>
<p>Our memory is the vector of <code>u8</code> , so read 4 elements from the memory and shift
them in the little-endian ordering.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...  
    fn fetch(&amp;self) -&gt; u32 {
        let index = self.pc as usize;
        return (self.dram[index] as u32)
            | ((self.dram[index + 1] as u32) &lt;&lt; 8)
            | ((self.dram[index + 2] as u32) &lt;&lt; 16)
            | ((self.dram[index + 3] as u32) &lt;&lt; 24);
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#decode-state" id="decode-state">Decode State</a></h3>
<p>RISC-V base instructions only have 4 instruction formats and a few variants as
we can see in Fig 1.2. These formats keep all register specifiers at the same
position in all formats since it makes it easier to decode.</p>
<p><img src="../img/1-1-2.png" alt="Fig 1.2 RISC-V base instruction formats. (Source: Figure 2.2 in Volume I: Unprivileged ISA)" /></p>
<p class="caption">Fig 1.2 RISC-V base instruction formats. (Source: Figure 2.2
in Volume I: Unprivileged ISA)</p>
<p>Decoding for common parts in all formats is performed by bitwise operations, bit
shifts and bitwise ANDs.</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ... 
    fn execute(&amp;mut self, inst: u32) {
        let opcode = inst &amp; 0x7f;
        let rd = ((inst &gt;&gt; 7) &amp; 0x1f) as usize;
        let rs1 = ((inst &gt;&gt; 15) &amp; 0x1f) as usize;
        let rs2 = ((inst &gt;&gt; 20) &amp; 0x1f) as usize;
        ...
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#execute-state" id="execute-state">Execute State</a></h3>
<p>As a first step, we're going to implement 2 instructions <code>add</code> (R-type) and
<code>addi</code> (I-type). The <code>add</code> instruction adds 64-bit values in two registers,
and the <code>addi</code> instruction adds a 64-bit value in a register and a 12-bit
immediate value. We can dispatch an execution depending on the <code>opcode</code> field
according to Fig 1.3 and Fig 1.4. In the <code>addi</code> instruction, we need to decode
12-bit immediate which is sign-extended.</p>
<p><img src="../img/1-1-3.png" alt="Fig 1.3 Add instruction (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<p class="caption">Fig 1.3 Add instruction (Source: RV32I Base Instruction Set
table in Volume I: Unprivileged ISA)</p>
<p><img src="../img/1-1-4.png" alt="Fig 1.4 Addi instruction (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<p class="caption">Fig 1.4 Addi instruction (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)</p>
<p class="filename">main.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...
    match opcode {
            0x13 =&gt; {
                // addi
                let imm = ((inst &amp; 0xfff00000) as i32 as i64 &gt;&gt; 20) as u64;
                self.regs[rd] = self.regs[rs1].wrapping_add(imm);
            }
            0x33 =&gt; {
                // add
                self.regs[rd] = self.regs[rs1].wrapping_add(self.regs[rs2]);
            }
            _ =&gt; {
                dbg!(&quot;not implemented yet&quot;);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The reason for using <code>wrapping_add</code> instead of plus (+) operation is to avoid
causing an arithmetic overflow when the result is beyond the boundary of the
type of registers which is a 64-bit unsigned integer.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>We're going to test 2 instructions by executing a sample file and check if the
registers are expected values. I prepared a sample binary file available at
<a href="https://github.com/d0iasm/rvemu-for-book/tree/master/01">d0iasm/rvemu-for-book/01/</a>.
Download the
<a href="https://github.com/d0iasm/rvemu-for-book/raw/master/01/add-addi.bin">add-addi.bin</a>
file and execute it in your emulator.</p>
<p>To see the registers after execution is done, I added the
<a href="https://github.com/d0iasm/rvemu-for-book/blob/master/01/src/main.rs#L33-L53"><code>dump_registers</code></a>
function. Now, we successfully see the result of the addition in the x31
register when we execute the sample binary file.</p>
<pre><code class="language-bash">// add-addi.bin is binary to execute these instructions:
// main:
// .  addi x29, x0, 5   // Add 5 and 0, and store the value to x29.
// .  addi x30, x0, 37  // Add 37 and 0, and store the value to x30.
// .  add x31, x30, x29 // x31 should contain 42 (0x2a).

$ cargo run add-addi.bin
...
x28=0x0 x29=0x5 x30=0x25 x31=0x2a
</code></pre>
<h3><a class="header" href="#how-to-build-test-binary" id="how-to-build-test-binary">How to Build Test Binary</a></h3>
<p>Our emulator can execute an ELF binary without any headers and its entry point
address is <code>0x0</code> . The
<a href="https://github.com/d0iasm/rvemu-for-book/blob/master/01/Makefile">Makefile</a>
helps you build test binary.</p>
<pre><code class="language-bash">$ riscv64-unknown-elf-gcc -Wl,-Ttext=0x0 -nostdlib -o foo foo.s
$ riscv64-unknown-elf-objcopy -O binary foo foo.bin
</code></pre>
<h3><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h3>
<p>The sample file doesn't cover edge cases (e.g. arithmetic overflow). We'll not
aim at the perfect implementation of our emulator in this page and in the
following pages because it costs too much. The book just focuses on running xv6
in our emulator and its implementation is possibly wrong or not enough.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../hardware-components/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../hardware-components/02-memory.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../hardware-components/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../hardware-components/02-memory.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
