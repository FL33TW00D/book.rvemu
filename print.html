<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing a RISC-V Emulator in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Writing a RISC-V emulator in Rust to aim to run xv6, a small Unix-like OS.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Writing a RISC-V Emulator in Rust</a></li><li class="chapter-item expanded "><a href="hardware-components/index.html"><strong aria-hidden="true">1.</strong> Hardware Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hardware-components/01-cpu.html"><strong aria-hidden="true">1.1.</strong> CPU with Two Instructions</a></li><li class="chapter-item expanded "><a href="hardware-components/02-memory.html"><strong aria-hidden="true">1.2.</strong> Memory and System Bus</a></li><li class="chapter-item expanded "><a href="hardware-components/03-csrs.html"><strong aria-hidden="true">1.3.</strong> Control and Status Registers</a></li><li class="chapter-item expanded "><a href="hardware-components/04-privileged-architecture.html"><strong aria-hidden="true">1.4.</strong> Privileged Architecture</a></li><li class="chapter-item expanded "><a href="hardware-components/05-exceptions.html"><strong aria-hidden="true">1.5.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="hardware-components/06-plic-and-clint.html"><strong aria-hidden="true">1.6.</strong> PLIC and CLINT</a></li><li class="chapter-item expanded "><a href="hardware-components/07-uart.html"><strong aria-hidden="true">1.7.</strong> UART</a></li><li class="chapter-item expanded "><a href="hardware-components/08-interrupts.html"><strong aria-hidden="true">1.8.</strong> Interrupts</a></li></ol></li><li class="chapter-item expanded "><a href="instruction-set/index.html"><strong aria-hidden="true">2.</strong> Instruction Set</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="instruction-set/01-rv64i.html"><strong aria-hidden="true">2.1.</strong> RV64I Base Integer Instruction Set</a></li><li class="chapter-item expanded "><a href="instruction-set/02-rv64m.html"><strong aria-hidden="true">2.2.</strong> &quot;M&quot; Standard Extension for Integer Multiplication and Division</a></li><li class="chapter-item expanded "><a href="instruction-set/03-rv64a.html"><strong aria-hidden="true">2.3.</strong> &quot;A&quot; Standard Extension for AtomicInstructions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing a RISC-V Emulator in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#writing-a-risc-v-emulator-in-rust" id="writing-a-risc-v-emulator-in-rust">Writing a RISC-V Emulator in Rust</a></h1>
<p><strong>NOTE: This project is actively ongoing. Pages are not perfect and they can change soon.</strong></p>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>This is the book for writing a 64-bit RISC-V emulator from scratch in Rust. You can run <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a simple Unix-like OS, in your emulator once you finish the book.</p>
<p>You'll learn the basic computer architecture such as ISA, previleged architecture, exceptions, interrupts, peripheral devices, and virtual memory system from making an emulator.</p>
<p>The source code used in this book is available at <a href="https://github.com/d0iasm/rvemu-for-book">d0iasm/rvemu-for-book</a>.</p>
<h2><a class="header" href="#chapter-1" id="chapter-1">Chapter 1</a></h2>
<p><a href="hardware-components/index.html">Chapter 1</a> shows all hardward components we need to implement for running <code>xv6</code>.</p>
<ol>
<li><a href="hardware-components/01-cpu.html">CPU with Two Instructions</a></li>
<li><a href="hardware-components/02-memory.html">Memory and System Bus</a></li>
<li><a href="hardware-components/03-csrs.html">Control and Status Registers</a></li>
<li><a href="hardware-components/04-privileged-architecture.html">Privileged Architecture</a></li>
<li><a href="hardware-components/05-exceptions.html">Exceptions</a></li>
<li><a href="hardware-components/06-plic-and-clint.html">PLIC (a platform-level interrupt controller) and CLINT (a core-local interrupter)</a></li>
<li><a href="hardware-components/07-uart.html">UART (a universal asynchronous receiver-transmitter)</a></li>
<li><a href="hardware-components/08-interrupts.html">Interrupts</a></li>
<li>Virtio</li>
<li>Virtual Memory System</li>
</ol>
<h2><a class="header" href="#chapter-2" id="chapter-2">Chapter 2</a></h2>
<p><a href="instruction-set/index.html">Chapter 2</a> shows all ISAs we need to implement for running <code>xv6</code>.</p>
<ul>
<li><a href="instruction-set/01-rv64i.html">RV64I Base Integer Instruction Set</a></li>
<li><a href="instruction-set/02-rv64m.html">&quot;M&quot; Standard Extension for Integer Multiplication and Division</a></li>
<li><a href="instruction-set/03-rv64a.html">&quot;A&quot; Standard Extension for AtomicInstructions</a></li>
</ul>
<h2><a class="header" href="#outcome" id="outcome">Outcome</a></h2>
<p>Once you read this book and implement the emulator, you will be able to run xv6 in your emulator!</p>
<p><img src="img/2020-08-16-rvemu-for-book-xv6.png" alt="Demo for running xv6 on the emulator" /></p>
<h2><a class="header" href="#contact" id="contact">Contact</a></h2>
<p>The author is <a href="https://twitter.com/d0iasm">@d0iasm</a> and please feel free to ask and request anything to me via <a href="https://twitter.com/d0iasm">Twitter</a> or <a href="https://github.com/d0iasm/rvemu-for-book/issues">GitHub issues</a>!</p>
<h1><a class="header" href="#hardware-components" id="hardware-components">Hardware Components</a></h1>
<p><a href="hardware-components/index.html">Chapter 1</a> shows all hardward components we need to implement for running <code>xv6</code>.</p>
<ol>
<li><a href="hardware-components/01-cpu.html">CPU with Two Instructions</a></li>
<li><a href="hardware-components/02-memory.html">Memory and System Bus</a></li>
<li><a href="hardware-components/03-csrs.html">Control and Status Registers</a></li>
<li><a href="hardware-components/04-privileged-architecture.html">Privileged Architecture</a></li>
<li><a href="hardware-components/05-exceptions.html">Exceptions</a></li>
<li><a href="hardware-components/06-plic-and-clint.html">PLIC (a platform-level interrupt controller) and CLINT (a core-local interrupter)</a></li>
<li><a href="hardware-components/07-uart.html">UART (a universal asynchronous receiver-transmitter)</a></li>
<li><a href="hardware-components/08-interrupts.html">Interrupts</a></li>
<li>Virtio</li>
<li>Virtual Memory System</li>
</ol>
<h1><a class="header" href="#cpu-with-two-instructions" id="cpu-with-two-instructions">CPU with Two Instructions</a></h1>
<p>This is a part of the <a href="hardware-components/../">Writing a RISC-V Emulator in Rust</a>. Our goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code used in this page is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step01">d0iasm/rvemu-for-book/step01/</a>.</p>
<h2><a class="header" href="#the-goal-of-this-page" id="the-goal-of-this-page">The Goal of This Page</a></h2>
<p>At the end of this page, we can implement a simple CPU and we can execute <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step01/add-addi.s">the sample file</a> containing <code>add</code> and <code>addi</code> instructions in our emulator. The <code>add</code> instruction adds 64-bit values in two registers, and the <code>addi</code> instruction adds a 64-bit value in a register and a 12-bit immediate value.</p>
<p>Sample binary files are also available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step01">d0iasm/rvemu-for-book/step01/</a>. We successfully see the result of addition in the <code>x31</code> register when we execute the sample binary file <code>add-addi.bin</code>.</p>
<pre><code class="language-bash">// add-addi.bin contains the following instructions:
// main:
// .  addi x29, x0, 5   // Add 5 and 0, and store the value to x29.
// .  addi x30, x0, 37  // Add 37 and 0, and store the value to x30.
// .  add x31, x30, x29 // x31 should contain 42 (0x2a).

$ cargo run add-addi.bin
...
x28=0x0 x29=0x5 x30=0x25 x31=0x2a
</code></pre>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p><a href="https://riscv.org/">RISC-V</a> is a new instruction-set architecture (ISA) that was originally designed to support computer architecture research and education at the University of California, Berkeley, but now it gradually becomes a standard free and open architecture for industry implementations. RISC-V is also excellent <strong>for students to learn computer architecture</strong> since it's simple enough. We can read <a href="https://riscv.org/technical/specifications/">the RISC-V specifications</a> for free and we'll implement a part of features in <em>Volume I: Unprivileged ISA</em> and <em>Volume II: Privileged Architecture</em>. The <em>Unprivileged ISA</em> defines instructions, the binary that the computer processor (CPU) can understand. Currently, RISC-V defines 32-bit and 64-bit architecture. The width of registers and the available memory size is different depending on the architecture. The 128-bit architecture also exists but it is currently in a draft state. </p>
<p><a href="https://www.rust-lang.org/">Rust</a> is an open-source systems programming language that focuses on performance and safety. It is popular especially in systems programming like an operating system. We're going to implement our emulator in Rust.</p>
<p>An emulator is, in simple words, <strong>an infinite loop to execute a RISC-V binary one by one</strong> unless something wrong happens or a user stops an emulator explicitly. In this book, we try to understand the basic RISC-V architecture by making a RISC-V emulator.</p>
<h2><a class="header" href="#risc-v-isa" id="risc-v-isa">RISC-V ISA</a></h2>
<p>RISC-V ISA consists of modules, a base integer ISA plus optional extensions. The base integer ISA must be implemented in any platform. There are 2 variants in the base integer ISA, <strong>RV32I</strong> in a 32-bit architecture and <strong>RV64I</strong> in a 64-bit architecture.</p>
<p>The base integer ISA only contains simple integer arithmetic operations so it's not enough so that it can't run complex systems such as OSes. RISC-V defines a combination of a base ISA plus selected extensions as a &quot;general-purpose&quot; ISA, called <strong>RV32G</strong> or <strong>RV64G</strong>, to allow complex systems to run on RISC-V hardware.</p>
<p>Here is the list of ISAs that RV64G includes:</p>
<ul>
<li>RV64I: base integer instructions</li>
<li>RV64M: integer multiplication and division instructions</li>
<li>RV64A: atomic instructions</li>
<li>RV64F: single-precision floating-point instructions</li>
<li>RV64D: double-precision floating-point instructions</li>
<li>RVZicsr: control and status register instructions</li>
<li>RVZifencei: instruction-fetch fence instructions</li>
</ul>
<p>We'll only support the instructions that xv6 uses which are RV64I, RVZicsr, a part of RV64M, and a part of RV64A.</p>
<h2><a class="header" href="#build-risc-v-toolchain" id="build-risc-v-toolchain">Build RISC-V Toolchain</a></h2>
<p>First, we need to build a RISC-V toolchain for RV64G. The default toolchain will use RV64GC which contains a general-purpose ISA and a compressed ISA. However, we will not support the compressed ISA in our emulator so we need to tell the architecture we use to the toolchain.</p>
<p>Download code from the <a href="https://github.com/riscv/riscv-gnu-toolchain">riscv/riscv-gnu-toolchain</a> repository and configure it with RV64G architecture. After executing the following commands, we can use <code>riscv64-unknown-elf-*</code> commands.</p>
<pre><code class="language-bash">$ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
$ cd riscv-gnu-toolchain
$ ./configure --prefix=&lt;path-to-riscv-toolchain&gt; --with-arch=rv64g
$ make &amp;&amp; make linux
// Now we can use riscv64-unknown-elf-* commands!
</code></pre>
<h2><a class="header" href="#create-a-new-project" id="create-a-new-project">Create a New Project</a></h2>
<p>We'll use Cargo, the Rust package manager. See <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">the installation page</a> in the Cargo book to install it. I'll call our project <code>rvemu-for-book</code> because I originally implemented <a href="https://github.com/d0iasm/rvemu">rvemu</a> and I refactored <a href="https://github.com/d0iasm/rvemu-for-book">the code for this book</a>.</p>
<p>The command <code>cargo new</code> can make a new project. We can see &quot;Hello, world!&quot; when we execute an initialized project by <code>cargo run</code>.</p>
<pre><code class="language-bash">$ cargo new rvemu-for-book
$ cd rvemu-for-book
$ cargo run
Hello, world!
</code></pre>
<h2><a class="header" href="#create-a-basic-cpu" id="create-a-basic-cpu">Create a Basic CPU</a></h2>
<p>CPU is the most important part of a computer to execute instructions. It has <strong>registers</strong>, a small amount of fast storage that a CPU can access. The width of registers is 64 bits in the 64-bit RISC-V architecture. It also has <strong>a program counter</strong> to hold the address of the current instruction.</p>
<p>The following struct contains 32 registers, a program counter, and memory. Actual hardware doesn't have a memory inside a CPU and the memory connects to the CPU via a system bus. We will make a memory and system bus module on the next page, and we create a CPU that contains a memory directly for now.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cpu {
    regs: [u64; 32],
    pc: u64,
    memory: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#registers" id="registers">Registers</a></h3>
<p>There are 32 general-purpose registers that are each 64 bits wide in RV64I. Each register has a role defined by <a href="https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#integer-register-convention-">the integer register convention</a>. Basically, an emulator doesn't care about the roles of a register except zero (x0) and sp (x2) registers. The zero register x0 is hardwired with all bits equal to 0. The sp register x2 is a stack pointer. A stack is a data structure mainly located at the end of the address space. It is especially used to store local variables. A stack pointer keeps track of a stack. A value of a stack pointer is subtracted in <a href="https://en.wikipedia.org/wiki/Function_prologue">a function prologue</a>, so we need to set it up with a non-0 value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set the register x2 with the size of a memory when a CPU is
// instantiated.
regs[2] = MEMORY_SIZE; // 1024 * 1024 * 128 (128MiB).

// Reset the value of register x0 with 0 in each cycle to mimic that
// register x0 is hardwired with all bits equal to 0.
self.regs[0] = 0;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fetch-decode-execute-cycle" id="fetch-decode-execute-cycle">Fetch-decode-execute Cycle</a></h3>
<p>The main job of the CPU is composed of three main stages: fetch stage, decode stage, and execute stage. The fetch-decode-execute cycle is also known as the instruction cycle. A CPU follows the cycle from the computer boots up until it shuts down.</p>
<ol>
<li>Fetch: Reads the next instruction to be executed from the memory where the program is stored.</li>
<li>Decode: Splits an instruction sequence into a form that makes sense to the CPU.</li>
<li>Execute: Performs the action required by the instruction.</li>
</ol>
<p>Also, we need to add 4 bytes, the size of one instruction, to the program counter in each cycle.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    ...
    while cpu.pc &lt; cpu.memory.len() as u64 {
        // 1. Fetch.
        let inst = cpu.fetch();

        // 2. Add 4 to the program counter.
        cpu.pc = cpu.pc + 4;

        // 3. Decode.
        // 4. Execute.
        cpu.execute(inst);
    }
    ...
</code></pre></pre>
<p>{% endcode %}</p>
<p>We'll make <code>fetch</code> and <code>execute</code> methods in CPU. The decode stage is performed in the <code>execute</code> method for the sake of simplicity.</p>
<p>{% code title=&quot;src.main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    fn fetch(&amp;self) -&gt; u32 {
        // Read 32-bit instruction from a memory.
    }

    fn execute(&amp;mut self, inst: u32) {
        // Decode an instruction and execute it.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#set-binary-data-to-the-memory" id="set-binary-data-to-the-memory">Set Binary Data to the Memory</a></h3>
<p>In order to implement the <code>fetch</code> method, we need to read a binary file from a command line and store the content in the memory. We can get command-line arguments via the standard <code>env</code> module. Let a file name place at the first argument.</p>
<p>The binary is set up to the memory when a new CPU instance is created.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() -&gt; io::Result&lt;()&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();

    if args.len() != 2 {
        panic!(&quot;Usage: rvemu-simple &lt;filename&gt;&quot;);
    }
    let mut file = File::open(&amp;args[1])?;
    let mut binary = Vec::new();
    file.read_to_end(&amp;mut binary)?;

    let cpu = Cpu::new(binary);

    ...
}

impl Cpu {
    fn new(binary: Vec&lt;u8&gt;) -&gt; Self {
        Self {
            regs: [0; 32],
            pc: 0,
            memory: binary,
        }
    }

    fn fetch(&amp;self) -&gt; u32 { ... }
    fn execute(&amp;mut self, inst: u32) { ... }
}
</code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#fetch-stage" id="fetch-stage">Fetch Stage</a></h3>
<p>Now, we are ready to fetch an instruction from the memory.</p>
<p>What we should be careful to fetch an instruction is endianness, which is the term refers to how binary data is stored. There are 2 types of endianness: little-endian and big-endian. A little-endian ordering places the least significant byte (LSB) at the lowest address and the most significant byte (MSB) places at the highest address in a 32-bit word. While a big-endian ordering does the opposite.</p>
<p><img src="hardware-components/../.gitbook/assets/risc-v_-endianness-2.png" alt="Fig 1.1 Little-endian and big-endian 2 instructions." /></p>
<p>RISC-V has either little-endian or big-endian byte order. Our emulator only supports a little-endian system because RISC-V originally chose little-endian byte ordering and it's currently dominant commercially like x86 systems.</p>
<p>Our memory is the vector of <code>u8</code> , so read 4 elements from the memory and shift them in the little-endian ordering.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...  
    fn fetch(&amp;self) -&gt; u32 {
        let index = self.pc as usize;
        return (self.memory[index] as u32)
            | ((self.memory[index + 1] as u32) &lt;&lt; 8)
            | ((self.memory[index + 2] as u32) &lt;&lt; 16)
            | ((self.memory[index + 3] as u32) &lt;&lt; 24);
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#decode-state" id="decode-state">Decode State</a></h3>
<p>RISC-V base instructions only have 4 instruction formats and a few variants as we can see in Fig 1.2. These formats keep all register specifiers at the same position in all formats since it makes it easier to decode.</p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-base-instruction-formats.png" alt="Fig 1.2 RISC-V base instruction formats. (Source: Figure 2.2 in Volume I: Unprivileged ISA) " /></p>
<p>Decoding for common parts in all formats is performed by bitwise operations, bit shifts and bitwise ANDs.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ... 
    fn execute(&amp;mut self, inst: u32) {
        let opcode = inst &amp; 0x7f;
        let rd = ((inst &gt;&gt; 7) &amp; 0x1f) as usize;
        let rs1 = ((inst &gt;&gt; 15) &amp; 0x1f) as usize;
        let rs2 = ((inst &gt;&gt; 20) &amp; 0x1f) as usize;
        ...
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#execute-state" id="execute-state">Execute State</a></h3>
<p>As a first step, we're going to implement 2 instructions <code>add</code> (R-type) and <code>addi</code> (I-type). The <code>add</code> instruction adds 64-bit values in two registers, and the <code>addi</code> instruction adds a 64-bit value in a register and a 12-bit immediate value. We can dispatch an execution depending on the <code>opcode</code> field according to Fig 1.3 and Fig 1.4. In the <code>addi</code> instruction, we need to decode 12-bit immediate which is sign-extended.</p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-add.png" alt="Fig 1.3 Add instruction (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-addi.png" alt="Fig 1.4 Addi instruction (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...
    match opcode {
            0x13 =&gt; {
                // addi
                let imm = ((inst &amp; 0xfff00000) as i32 as i64 &gt;&gt; 20) as u64;
                self.regs[rd] = self.regs[rs1].wrapping_add(imm);
            }
            0x33 =&gt; {
                // add
                self.regs[rd] = self.regs[rs1].wrapping_add(self.regs[rs2]);
            }
            _ =&gt; {
                dbg!(&quot;not implemented yet&quot;);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<p>The reason for using <code>wrapping_add</code> instead of plus (+) operation is to avoid causing an arithmetic overflow when the result is beyond the boundary of the type of registers which is a 64-bit unsigned integer.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>We're going to test 2 instructions by executing a sample file and check if the registers are expected values. I prepared a sample binary file available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step01">d0iasm/rvemu-for-book/step01/</a>. Download the <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step01/add-addi.bin">add-addi.bin</a> file and execute it in your emulator.</p>
<p>To see the registers after execution is done, I added the <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step01/src/main.rs#L33-L53"><code>dump_registers</code></a> function. Now, we successfully see the result of the addition in the x31 register when we execute the sample binary file.</p>
<pre><code class="language-bash">// add-addi.bin is binary to execute these instructions:
// main:
// .  addi x29, x0, 5   // Add 5 and 0, and store the value to x29.
// .  addi x30, x0, 37  // Add 37 and 0, and store the value to x30.
// .  add x31, x30, x29 // x31 should contain 42 (0x2a).

$ cargo run add-addi.bin
...
x28=0x0 x29=0x5 x30=0x25 x31=0x2a
</code></pre>
<h3><a class="header" href="#how-to-build-test-binary" id="how-to-build-test-binary">How to Build Test Binary</a></h3>
<p>Our emulator can execute an ELF binary without any headers and its entry point address is <code>0x0</code> . The <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step01/Makefile">Makefile</a> helps you build test binary.</p>
<pre><code class="language-bash">$ riscv64-unknown-elf-gcc -Wl,-Ttext=0x0 -nostdlib -o foo foo.s
$ riscv64-unknown-elf-objcopy -O binary foo foo.bin
</code></pre>
<h3><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h3>
<p>The sample file doesn't cover edge cases (e.g. arithmetic overflow). We'll not aim at the perfect implementation of our emulator in this step and in the following steps because it costs too much. The book just focuses on running xv6 in our emulator and its implementation is possibly wrong or not enough.</p>
<h1><a class="header" href="#memory-and-system-bus" id="memory-and-system-bus">Memory and System Bus</a></h1>
<p>This is a part of the <a href="hardware-components/../">Writing a RISC-V Emulator in Rust</a>. Our goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code used in this page is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step02">d0iasm/rvemu-for-book/step02/</a>.</p>
<h2><a class="header" href="#goal-of-this-page" id="goal-of-this-page">Goal of This Page</a></h2>
<p>At the end of this page, we can implement memory and system bus. The memory is a dynamic random-access memory (DRAM) to store data while executing a program. The system bus is a pathway to carry data between the CPU and the memory.</p>
<h2><a class="header" href="#cpu-module" id="cpu-module">CPU Module</a></h2>
<p>First, we're going to divide the implementation of the CPU from the <code>main.rs</code> file. Rust provides a module system to split code into logical units and organize visibility. We're going to move the implementation of CPU to a new file <code>cpu.rs</code>.</p>
<p>In order to define a cpu module we need to <code>mod</code> keyword at the beginning of the main file. Also <code>use</code> keyword allows us to use public items in the cpu module.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This declaration will look for a file named `cpu.rs` or `cpu/mod.rs` and will
// insert its contents inside a module named `cpu` under this scope.
mod cpu;

// Use all public structures, methods, and functions defined in the cpu module.
use crate::cpu::*;
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `pub` keyword allows other modules use the `Cpu` structure and methods
// relating to it. 
pub struct Cpu {
    ...
}

impl Cpu {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#fetch-decode-execute-cycle-1" id="fetch-decode-execute-cycle-1">Fetch-decode-execute Cycle</a></h3>
<p>The previous step already mentioned the fetch-decode-execute cycle and we're going to implement it in the <code>main.rs</code>. An emulator is ideally an infinite loop and executes the program infinitely unless something wrong happens or a user stops an emulator explicitly. However, we're going to stop an emulator implicitly when the program counter is 0 or over the length of memory, and an error happens during the execution.</p>
<p>{% code title=&quot;src/main.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    ...
    while cpu.pc &lt; cpu.memory.len() as u64 {
        // 1. Fetch
        let inst = cpu.fetch();

        // 2. Add 4 to the program counter.
        cpu.pc += 4;

        // 3. Decode.
        // 4. Execute.
        match cpu.execute(inst) {
            // True if an error happens.
            true =&gt; break,
            false =&gt; {}
        };

        // This is a workaround for avoiding an infinite loop.
        if cpu.pc == 0 {
            break;
        }
    }
    ...
}
</code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#fetch-stage-1" id="fetch-stage-1">Fetch Stage</a></h3>
<p>The fetch stage is basically the same as the previous step, but I prefer to create a new function to read 32-bit data from a memory because there are other instructions to read and write memory.</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ...  
    fn read32(&amp;self, addr: u64) -&gt; u64 {
        let index = addr as usize;
        return (self.memory[index] as u64)
            | ((self.memory[index + 1] as u64) &lt;&lt; 8)
            | ((self.memory[index + 2] as u64) &lt;&lt; 16)
            | ((self.memory[index + 3] as u64) &lt;&lt; 24);
    }
    ...    
    pub fn fetch(&amp;self) -&gt; u32 {
        return self.read32(self.pc) as u32;
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#decode-stage" id="decode-stage">Decode Stage</a></h3>
<p>The decode stage is almost the same as the previous step too and we'll add 2 new fields <code>funct3</code> and <code>funct7</code>. <code>funct3</code> is located from 12 to 14 bits and <code>funct7</code> is located from 25 to 31 bits as we can see in Fig 2.1 and 2.2. These fields and opcode select the type of operation.</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ... 
    fn execute(&amp;mut self, inst: u32) {
        ...
        let funct3 = (inst &amp; 0x00007000) &gt;&gt; 12;
        let funct7 = (inst &amp; 0xfe000000) &gt;&gt; 25;
        ...
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<p>In RISC-V, there are many common positions in all formats, but decoding an immediate value is quite different depending on instructions, so we'll decode an immediate value in each operation.</p>
<p>For example, the immediate value in branch instructions is located in the place of <code>rd</code> and <code>funct7</code>. A branch instruction is a <code>if</code> statement in C to change the sequence of instruction execution depending on a condition, which includes <code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bge</code>, <code>bltu</code>, and <code>bgeu</code>.</p>
<p>Decoding is performed by bitwise ANDs and bit shifts. The point to be noted is that an immediate value should be sign-extended. It means we need to fill in the upper bits with 1 when the significant bit is 1. In this implementation, filling in bits with 1 is performed by casting from a signed integer to an unsigned integer.</p>
<p>The way how to decode each instruction is listed in Fig 2.1 and Fig 2.2.</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ... 
    fn execute(&amp;mut self, inst: u32) {
        ...
        match opcode {
            0x63 =&gt; {
                // imm[12|10:5|4:1|11] = inst[31|30:25|11:8|7]
                let imm = (((inst &amp; 0x80000000) as i32 as i64 &gt;&gt; 19) as u64)
                    | ((inst &amp; 0x80) &lt;&lt; 4)   // imm[11]
                    | ((inst &gt;&gt; 20) &amp; 0x7e0) // imm[10:5]
                    | ((inst &gt;&gt; 7) &amp; 0x1e);  // imm[4:1]

                match funct3 {
                    ...
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h3><a class="header" href="#execute-stage" id="execute-stage">Execute Stage</a></h3>
<p>Each operation is performed in each <code>match</code> arm. For example, a branch instruction <code>beq</code>, which is one of the branch instructions, is executed when <code>opcode</code> is 0x63 and <code>funct3</code> is 0x0. <code>beq</code> sets the <code>pc</code> to the current <code>pc</code> plus the signed-extended offset if a value in <code>rs1</code> equals a value in <code>rs2</code>. The current <code>pc</code> means the position when CPU fetched an instruction from memory so we need to subtract 4 from <code>pc</code> because we added 4 after fetch.</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cpu {
    ... 
    fn execute(&amp;mut self, inst: u32) {
        ...
        match opcode {
            0x63 =&gt; {
                let imm = ...;

                match funct3 {
                    0x0 =&gt; {
                        // beq
                        if self.regs[rs1] == self.regs[rs2] {
                            self.pc = self.pc.wrapping_add(imm).wrapping_sub(4);
                        }
                    }
                ...
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h2><a class="header" href="#memory-module" id="memory-module">Memory Module</a></h2>
<p>// TODO: write this section</p>
<h2><a class="header" href="#system-bus-module" id="system-bus-module">System Bus Module</a></h2>
<p>// TODO: write this section</p>
<h2><a class="header" href="#instructions-list" id="instructions-list">Instructions List</a></h2>
<p>The following table is a brief explanation for each instruction. The book won't describe the details of each instruction but will indicate points to be noted when you implement instructions. In addition, you can see the implementation in <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step02/src/cpu.rs">d0iasm/rvemu-for-book/step02/src/cpu.rs</a> and description in <em>Chapter 2 RV32I Base Integer Instruction Set</em> and <em>Chapter 5 RV64I Base Integer Instruction Set</em> in <a href="https://riscv.org/specifications/isa-spec-pdf/">the unprivileged specification</a>.</p>
<p><strong>Points to be noted</strong>:</p>
<ul>
<li>Arithmetic operations are done by wrapping_* functions to avoid an overflow.</li>
<li>Sign-extended is done by casting from a smaller signed integer to a larger signed integer.</li>
<li>The amount for 64-bit shift operations is encoded in the lower 6 bits in an immediate, and the amount for 32-bit shift operations is encoded in the lower 5 bits.</li>
</ul>
<table><thead><tr><th align="left">Instruction</th><th align="left">Pseudocode</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><strong>lui</strong> rd, imm</td><td align="left">x[rd] = sext(imm[31:12] &lt;&lt; 12)</td><td align="left">Load upper immediate value.</td></tr>
<tr><td align="left"><strong>auipc</strong> rd, imm</td><td align="left">x[rd] = pc + sext(imm[31:12] &lt;&lt; 12)</td><td align="left">Add upper immediate value to PC.</td></tr>
<tr><td align="left"><strong>jal</strong> rd, offset</td><td align="left">x[rd] = pc + 4; pc += sext(offset)</td><td align="left">Jump and link.</td></tr>
<tr><td align="left"><strong>jalr</strong> rd, offset(rs1)</td><td align="left">t = pc+4; pc = (x[rs1] + sext(offset)&amp;~1); x[rd] = t</td><td align="left">Jump and link register.</td></tr>
<tr><td align="left"><strong>beq</strong> rs1, rs2, offset</td><td align="left">if (rs1 == rs2) pc += sext(offset)</td><td align="left">Branch if equal.</td></tr>
<tr><td align="left"><strong>bne</strong> rs1, rs2, offset</td><td align="left">if (rs1 != rs2) pc += sext(offset)</td><td align="left">Branch if not equal.</td></tr>
<tr><td align="left"><strong>blt</strong> rs1, rs2, offset</td><td align="left">if (rs1 &lt; rs2) pc += sext(offset)</td><td align="left">Branch if less than.</td></tr>
<tr><td align="left"><strong>bge</strong> rs1, rs2, offset</td><td align="left">if (rs1 &gt;= rs2) pc += sext(offset)</td><td align="left">Branch if greater than or equal.</td></tr>
<tr><td align="left"><strong>bltu</strong> rs1, rs2, offset</td><td align="left">if (rs1 &lt; rs2) pc += sext(offset)</td><td align="left">Branch if less than, unsigned.</td></tr>
<tr><td align="left"><strong>bgeu</strong> rs1, rs2, offset</td><td align="left">if (rs1 &gt;= rs2) pc += sext(offset)</td><td align="left">Branch if greater than or equal, unsigned.</td></tr>
<tr><td align="left"><strong>lb</strong> rd, offset(rs1)</td><td align="left">x[rd] = sext(M[x[rs1] + sext(offset)][7:0])</td><td align="left">Load byte (8 bits).</td></tr>
<tr><td align="left"><strong>lh</strong> rd, offset(rs1)</td><td align="left">x[rd] = sext(M[x[rs1] + sext(offset)][15:0])</td><td align="left">Load halfword (16 bits).</td></tr>
<tr><td align="left"><strong>lw</strong> rd, offset(rs1)</td><td align="left">x[rd] = sext(M[x[rs1] + sext(offset)][31:0])</td><td align="left">Load word (32 bits).</td></tr>
<tr><td align="left"><strong>lbu</strong> rd, offset(rs1)</td><td align="left">x[rd] = M[x[rs1] + sext(offset)][7:0]</td><td align="left">Load byte, unsigned.</td></tr>
<tr><td align="left"><strong>lhu</strong> rd, offset(rs1)</td><td align="left">x[rd] = M[x[rs1] + sext(offset)][15:0]</td><td align="left">Load halfword, unsigned.</td></tr>
<tr><td align="left"><strong>sb</strong> rs2, offset(rs1)</td><td align="left">M[x[rs1] + sext(offset)] = x[rs2][7:0]</td><td align="left">Store byte.</td></tr>
<tr><td align="left"><strong>sh</strong> rs2, offset(rs1)</td><td align="left">M[x[rs1] + sext(offset)] = x[rs2][15:0]</td><td align="left">Store halfword.</td></tr>
<tr><td align="left"><strong>sw</strong> rs2, offset(rs1)</td><td align="left">M[x[rs1] + sext(offset)] = x[rs2][31:0]</td><td align="left">Store word.</td></tr>
<tr><td align="left"><strong>addi</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] + sext(imm)</td><td align="left">Add immediate.</td></tr>
<tr><td align="left"><strong>slti</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] &lt; x[rs2]</td><td align="left">Set if less than.</td></tr>
<tr><td align="left"><strong>sltiu</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] &lt; x[rs2]</td><td align="left">Set if less than, unsigned.</td></tr>
<tr><td align="left"><strong>xori</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] ^ sext(imm)</td><td align="left">Exclusive OR immediate.</td></tr>
<tr><td align="left"><strong>ori</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] | sext(imm)</td><td align="left">OR immediate.</td></tr>
<tr><td align="left"><strong>andi</strong> rd, rs1, imm</td><td align="left">x[rd] = x[rs1] &amp; sext(imm)</td><td align="left">AND immediate.</td></tr>
<tr><td align="left"><strong>slli</strong> rd, rs1, shamt</td><td align="left">x[rd] = x[rs1] &lt;&lt; shamt</td><td align="left">Shift left logical immediate.</td></tr>
<tr><td align="left"><strong>srli</strong> rd, rs1, shamt</td><td align="left">x[rd] = x[rs1] &gt;&gt; shamt</td><td align="left">Shift right logical immediate.</td></tr>
<tr><td align="left"><strong>srai</strong> rd, rs1, shamt</td><td align="left">x[rd] = x[rs1] &gt;&gt; shamt</td><td align="left">Shift right arithmetic immediate.</td></tr>
<tr><td align="left"><strong>add</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] + x[rs2]</td><td align="left">Add.</td></tr>
<tr><td align="left"><strong>sub</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] - x[rs2]</td><td align="left">Subtract.</td></tr>
<tr><td align="left"><strong>sll</strong> rs, rs1, rs2</td><td align="left">x[rd] = x[rs1] &lt;&lt; x[rs2]</td><td align="left">Shift left logical.</td></tr>
<tr><td align="left"><strong>slt</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] &lt; x[rs2]</td><td align="left">Set if less than.</td></tr>
<tr><td align="left"><strong>sltu</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] &lt; x[rs2]</td><td align="left">Set if less than, unsigned.</td></tr>
<tr><td align="left"><strong>xor</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] ^ x[rs2]</td><td align="left">Exclusive OR.</td></tr>
<tr><td align="left"><strong>srl</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] &gt;&gt; x[rs2]</td><td align="left">Shift right logical.</td></tr>
<tr><td align="left"><strong>sra</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] &gt;&gt; x[rs2]</td><td align="left">Shift right arithmetic.</td></tr>
<tr><td align="left"><strong>or</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] | x[rs2]</td><td align="left">OR.</td></tr>
<tr><td align="left"><strong>and</strong> rd, rs1, rs2</td><td align="left">x[rd] = x[rs1] &amp; x[rs2]</td><td align="left">AND.</td></tr>
<tr><td align="left"><strong>lwu</strong> rd, offset(rs1)</td><td align="left">x[rd] = M[x[rs1] + sext(offset)][31:0]</td><td align="left">Load word, unsigned.</td></tr>
<tr><td align="left"><strong>ld</strong> rd, offset(rs1)</td><td align="left">x[rd] = M[x[rs1] + sext(offset)][63:0]</td><td align="left">Load doubleword (64 bits), unsigned.</td></tr>
<tr><td align="left"><strong>sd</strong> rs2, offset(rs1)</td><td align="left">M[x[rs1] + sext(offset)] = x[rs2][63:0]</td><td align="left">Store doubleword.</td></tr>
<tr><td align="left"><strong>addiw</strong> rd, rs1, imm</td><td align="left">x[rd] = sext((x[rs1] + sext(imm))[31:0])</td><td align="left">Add word immediate.</td></tr>
<tr><td align="left"><strong>slliw</strong> rd, rs1, shamt</td><td align="left">x[rd] = sext((x[rs1] &lt;&lt; shamt)[31:0])</td><td align="left">Shift left logical word immediate.</td></tr>
<tr><td align="left"><strong>srliw</strong> rd, rs1, shamt</td><td align="left">x[rd] = sext((x[rs1] &gt;&gt; shamt)[31:0])</td><td align="left">Shift right logical word immediate.</td></tr>
<tr><td align="left"><strong>sraiw</strong> rd, rs1, shamt</td><td align="left">x[rd] = sext((x[rs1] &gt;&gt; shamt)[31:0])</td><td align="left">Shift right arithmetic word immediate.</td></tr>
<tr><td align="left"><strong>addw</strong> rd, rs1, rs2</td><td align="left">x[rd] = sext((x[rs1] + x[rs2])[31:0])</td><td align="left">Add word.</td></tr>
<tr><td align="left"><strong>subw</strong> rd, rs1, rs2</td><td align="left">x[rd] = sext((x[rs1] - x[rs2])[31:0])</td><td align="left">Subtract word.</td></tr>
<tr><td align="left"><strong>sllw</strong> rd, rs1, rs2</td><td align="left">x[rd] = sext((x[rs1] &lt;&lt; x[rs2][4:0])[31:0])</td><td align="left">Shift left logical word.</td></tr>
<tr><td align="left"><strong>srlw</strong> rd, rs1, rs2</td><td align="left">x[rd] = sext(x[rs1][31:0] &lt;&lt; x[rs2][4:0])</td><td align="left">Shift right logical word.</td></tr>
<tr><td align="left"><strong>sraw</strong> rd, rs1, rs2</td><td align="left">x[rd] = sext(x[rs1][31:0] &lt;&lt; x[rs2][4:0])</td><td align="left">Shift right arithmetic word.</td></tr>
</tbody></table>
<h2><a class="header" href="#testing-1" id="testing-1">Testing</a></h2>
<p>We're going to test instructions we implemented in this step by calculating <a href="https://en.wikipedia.org/wiki/Fibonacci_number">a Fibonacci number</a> and check if the registers are expected values. I prepared a sample binary file available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step02">d0iasm/rvemu-for-book/step02/</a>. Download the <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step02/fib.bin">fib.bin</a> file and execute it in your emulator.</p>
<p>Calculating a Fibonacci number is actually not enough to test all RV64I instructions, so it perhaps be better to use <a href="https://github.com/riscv/riscv-tests">riscv/riscv-tests</a> to make sure if your implementation is correct. However, it's not obvious how to use riscv-tests so I'll skip to use the test in this book for the sake of simplicity. If you are interested in using riscv-tests, <a href="https://github.com/d0iasm/rvemu/blob/master/tests/rv64_user.rs">the test file in rvemu</a> may be helpful.</p>
<pre><code class="language-text">// fib.c contains the following C code and fib.bin is the build result of it:
// int fib(int n);
// int main() {
//   return fib(10); // Calculate the 10th fibonacci number.
// }
// int fib(int n) {
//   if (n == 0 || n == 1)
//     return n;
//   else
//     return (fib(n-1) + fib(n-2));
// }

$ cargo run fib.bin
...           
x12=0x0 x13=0x0 x14=0x1 x15=0x37 // x15 should contain 55 (= 10th fibonacci number).
</code></pre>
<h3><a class="header" href="#how-to-build-test-binary-1" id="how-to-build-test-binary-1">How to Build Test Binary</a></h3>
<p>If you want to execute a bare-metal C program you write, you need to make an ELF binary without any headers because our emulator just starts to execute at the address <code>0x0</code> . The <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step02/Makefile">Makefile</a> helps you build a test binary.</p>
<pre><code class="language-bash">$ riscv64-unknown-elf-gcc -S fib.c
$ riscv64-unknown-elf-gcc -Wl,-Ttext=0x0 -nostdlib -o fib fib.s
$ riscv64-unknown-elf-objcopy -O binary fib fib.bin
</code></pre>
<h1><a class="header" href="#control-and-status-registers" id="control-and-status-registers">Control and Status Registers</a></h1>
<p>This is step 3 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step03">d0iasm/rvemu-for-book/step03/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-1" id="goal-of-this-page-1">Goal of This Page</a></h2>
<p>In the end of this page, we can execute the sample file containing CSR instructions, <code>csrrw</code>, <code>csrrs</code>, <code>csrrc</code>, <code>csrrwi</code>, <code>csrrsi</code>, and <code>csrrci</code>.</p>
<h2><a class="header" href="#control-and-status-registers-csrs" id="control-and-status-registers-csrs">Control and Status Registers (CSRs)</a></h2>
<p>Control and status register (CSR) is a register that stores various information in CPU. RISC-V defines a separate address space of 4096 CSRs associated with each hardware thread so we can have at most 4096 CSRs. RISC-V only allocates a part of address space so we can add custom CSRs if we want. Also, not all CSRs are required on all implementations. In this book, I'll describe only CSRs used in <a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv</a>.</p>
<p>First, we're going to add <code>csrs</code> field to <code>Cpu</code> structure. We already defined registers, a program counter, and memory and now we have 4 fields in CPU.</p>
<p>{% code title=&quot;src/cpu.rs&quot; %}</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cpu {
    /// 32 64-bit integer registers.
    pub regs: [u64; 32],
    /// Program counter to hold the the memory address of the next instruction that would be executed.
    pub pc: u64,
    /// Control and status registers. RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for
    /// up to 4096 CSRs.
    pub csrs: [u64; 4096],
    /// Computer memory to store executable instructions and the stack region.
    pub memory: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>{% endcode %}</p>
<h2><a class="header" href="#csr-instructions" id="csr-instructions">CSR Instructions</a></h2>
<p>Fig 3.4 is the list for instructions to read-modify-write CSRs. RISC-V calls the 6 instructions <em>Zicsr.</em> CSR specifier is encoded in the 12-bit <code>csr</code> field of the instruction held in bits 31–20. There are 12 bits for specifying which CSR is selected so it means we have 4096 CSRs (=2**12). The <code>uimm</code> field is unsigned immediate value, a 5-bit zero-extended.</p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-csr-instructions.png" alt="Fig 3.4 RV64Zicsr Instruction Set (Source: RV32/RV64 Zicsr Standard Extension table in Volume I: Unprivileged ISA)" /></p>
<h2><a class="header" href="#csr-list" id="csr-list">CSR List</a></h2>
<p>Fig 3.1-3.3 list the CSRs that are currently allocated CSR addresses.</p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-machine-csr-list.png" alt="Fig 3.1 Machine-level CSRs 1 (Source: Table 2.4: Currently allocated RISC-V machine-level CSR addresses. in Volume II: Privileged Architecture" /></p>
<p><img src="hardware-components/../.gitbook/assets/rvemu-machine-csr-list-2.png" alt="Fig 3.2 Machine-level CSRs 2 (Source: Table 2.5: Currently allocated RISC-V machine-level CSR addresses. in Volume II: Privileged Architecture" /></p>
<p><img src="hardware-components/../.gitbook/assets/rvemubook-supervisor-csr-list.png" alt="Fig 3.3 Supervisor-level CSRs (Source: Table 2.3: Currently allocated RISC-V supervisor-level CSR addresses. in Volume II: Privileged Architecture)" /></p>
<h2><a class="header" href="#testing-2" id="testing-2">Testing</a></h2>
<h1><a class="header" href="#privileged-architecture" id="privileged-architecture">Privileged Architecture</a></h1>
<p>This is step 4 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step04">d0iasm/rvemu-for-book/step04/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-2" id="goal-of-this-page-2">Goal of This Page</a></h2>
<p>In the end of this page, we can execute the part of supervisor ISA, <code>mret</code> and <code>sret</code>. These instructions are used to return from traps in M-mode, S-mode, or U-mode respectively. In addition, we'll add <code>sfence.vma</code> but we don't do anything for now.</p>
<h2><a class="header" href="#privilege-levels" id="privilege-levels">Privilege Levels</a></h2>
<h2><a class="header" href="#testing-3" id="testing-3">Testing</a></h2>
<h1><a class="header" href="#exceptions" id="exceptions">Exceptions</a></h1>
<p>This is step 5 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step05">d0iasm/rvemu-for-book/step05/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-3" id="goal-of-this-page-3">Goal of This Page</a></h2>
<p>In the end of this page, we support exceptions and can execute <code>ecall</code>, <code>ebreak</code> and <code>fence</code>, parts of the base integer instruction set (RV64I). The <code>ecall</code> and <code>ebreak</code> instructions raise an exception.</p>
<h2><a class="header" href="#exceptions-1" id="exceptions-1">Exceptions</a></h2>
<h2><a class="header" href="#testing-4" id="testing-4">Testing</a></h2>
<h1><a class="header" href="#plic-a-platform-level-interrupt-controller-and-clint-a-core-local-interrupter" id="plic-a-platform-level-interrupt-controller-and-clint-a-core-local-interrupter">PLIC (a platform-level interrupt controller) and CLINT (a core-local interrupter)</a></h1>
<p>This is step 6 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step06">d0iasm/rvemu-for-book/step06/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-4" id="goal-of-this-page-4">Goal of This Page</a></h2>
<p>In the end of this page, we can support a platform-level interrupt controller (PLIC) and a core-local interrupter (CLINT) as CPU's peripheral devices.</p>
<h2><a class="header" href="#testing-5" id="testing-5">Testing</a></h2>
<h1><a class="header" href="#uart-a-universal-asynchronous-receiver-transmitter" id="uart-a-universal-asynchronous-receiver-transmitter">UART (a universal asynchronous receiver-transmitter)</a></h1>
<p>This is step 7 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step07">d0iasm/rvemu-for-book/step07/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-5" id="goal-of-this-page-5">Goal of This Page</a></h2>
<p>In the end of this page, we can support a universal asynchronous receiver-transmitter (UART) as one of CPU's peripheral devices.</p>
<h2><a class="header" href="#testing-6" id="testing-6">Testing</a></h2>
<p>// TODO: print &quot;Hello, world!&quot; and echoback</p>
<h1><a class="header" href="#interrupts" id="interrupts">Interrupts</a></h1>
<p>This is step 8 of the book <a href="hardware-components/../"><em>Writing a RISC-V Emulator from Scratch in 10 Steps</em></a>, whose goal is running <a href="https://github.com/mit-pdos/xv6-riscv">xv6</a>, a small Unix-like OS, in your emulator in the final step.</p>
<p>The source code is available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step08">d0iasm/rvemu-for-book/step08/</a>.</p>
<h2><a class="header" href="#goal-of-this-page-6" id="goal-of-this-page-6">Goal of This Page</a></h2>
<p>In the end of this page, we support interrupts, external asynchronous events that may cause a hardware thread to experience an unexpected transfer of control.</p>
<h1><a class="header" href="#instruction-set" id="instruction-set">Instruction Set</a></h1>
<p><a href="instruction-set/instruction-set/index.html">Chapter 2</a> shows all ISAs we need to implement for running <code>xv6</code>.</p>
<ul>
<li><a href="instruction-set/01-rv64i.html">RV64I Base Integer Instruction Set</a></li>
<li><a href="instruction-set/02-rv64m.html">&quot;M&quot; Standard Extension for Integer Multiplication and Division</a></li>
<li><a href="instruction-set/03-rv64a.html">&quot;A&quot; Standard Extension for AtomicInstructions</a></li>
</ul>
<h1><a class="header" href="#rv64i-base-integer-instruction-set" id="rv64i-base-integer-instruction-set">RV64I Base Integer Instruction Set</a></h1>
<h2><a class="header" href="#goal-of-this-page-7" id="goal-of-this-page-7">Goal of This Page</a></h2>
<p>In the end of this page, we can execute <a href="https://github.com/d0iasm/rvemu-for-book/blob/master/step02/fib.c">the sample file</a> that calculates <a href="https://en.wikipedia.org/wiki/Fibonacci_number">a Fibonacci number</a> in our emulator. We will support RV64 ISAs, the base integer instruction set a 64-bit architecture, to calculate a Fibonacci number.</p>
<p>Sample binary files are also available at <a href="https://github.com/d0iasm/rvemu-for-book/tree/master/step02">d0iasm/rvemu-for-book/step02/</a>. We successfully see the result of the 10th Fibonacci number when we execute the sample binary file <code>fib.bin</code>.</p>
<pre><code class="language-text">// fib.c contains the following C code and fib.bin is the build result of it:
// int fib(int n);
// int main() {
//   return fib(10); // Calculate the 10th fibonacci number.
// }
// int fib(int n) {
//   if (n == 0 || n == 1)
//     return n;
//   else
//     return (fib(n-1) + fib(n-2));
// }

$ cargo run fib.bin
...           
x12=0x0 x13=0x0 x14=0x1 x15=0x37 // x15 should contain 55 (= 10th fibonacci number).
</code></pre>
<h2><a class="header" href="#rv64i-base-integer-instruction-set-1" id="rv64i-base-integer-instruction-set-1">RV64I: Base Integer Instruction Set</a></h2>
<p>RV64I is a base integer instruction set for the 64-bit architecture, which builds upon the RV32I variant. RV64I shares most of the instructions with RV32I but the width of registers is different and there are a few additional instructions only in RV64I.</p>
<p>In this step, we're going to implement 47 instructions (35 instructions from RV32I and 12 instructions from RV64I). We've already implemented <code>add</code> and <code>addi</code> so we'll skip them. Also, we'll skip implementing <code>fence</code>, <code>ecall</code>, and <code>ebreak</code> for now. I'll cover <code>ecall</code> and <code>ebreak</code> in the following step and won't explain <code>fence</code>. The <code>fence</code> instruction is a type of barrier instruction to apply an ordering constraint on memory operations issued before and after it. We don't need it since our emulator is a single core system and doesn't reorder memory operations (out-of-order execution).</p>
<p>Fig 2.1 and Fig 2.2 are the lists for RV32I and RV64I, respectively. We're going to implement all instructions in the figures.</p>
<p><img src="instruction-set/../.gitbook/assets/rvemubook-rv32i.png" alt="Fig 2.1 RV32I Base Instruction Set (Source: RV32I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<p><img src="instruction-set/../.gitbook/assets/screen-shot-2020-04-19-at-20.20.35.png" alt="Fig 2.2 RV64I Base Instruction Set (Source: RV64I Base Instruction Set table in Volume I: Unprivileged ISA)" /></p>
<h2><a class="header" href="#" id=""></a></h2>
<h1><a class="header" href="#m-standard-extension-for-integer-multiplication-and-division" id="m-standard-extension-for-integer-multiplication-and-division">&quot;M&quot; Standard Extension for Integer Multiplication and Division</a></h1>
<p>We also support a part of &quot;M&quot; standard extension since xv6 uses them. &quot;M&quot; standard extension is multiplication and division instructions (RV64M) and we'll implement <code>divu</code> and <code>remuw</code>.</p>
<h1><a class="header" href="#a-standard-extension-for-atomicinstructions" id="a-standard-extension-for-atomicinstructions">&quot;A&quot; Standard Extension for AtomicInstructions</a></h1>
<p>We also support a part of &quot;A&quot; standard extension since xv6 uses them. &quot;A&quot; standard extension is atomic instructions (RV64A) and we'll implement <code>amoadd.w</code>, <code>amoadd.d</code>, <code>amoswap.w</code> and <code>amoswap.d</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
